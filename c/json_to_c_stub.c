#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "json_to_c_stub.h"
#include "todo.h"
#include "albase.h"
/*
Sample of what should be autogenerated 
**/

// INPUT

struct test_1 {
  int a;
  int b;
  int c;
  char * d;
};

struct test_2 {
  int a;
  struct test_1 c;
  struct test_1 * e;
};

// OUTPUT ( currently not autogenerated but done manualy )

int json_c_test_1_from_json_auto( struct test_1* test, struct json_object * json_object)
{
  if AL_JSON_IS_DICT(json_object)
    {
      AL_GET_JSON_INT_WITH_NAME(test,a,json_object);
      AL_GET_JSON_INT_WITH_NAME(test,b,json_object);
      AL_GET_JSON_INT_WITH_NAME(test,c,json_object);
      AL_GET_JSON_STRING_WITH_NAME(test,d,json_object);
    }
  else if AL_JSON_IS_LIST(json_object)
    {
      AL_GET_JSON_INT_BY_ORDER(test,a,json_object,0);
      AL_GET_JSON_INT_BY_ORDER(test,b,json_object,1);
      AL_GET_JSON_INT_BY_ORDER(test,c,json_object,2);
      AL_GET_JSON_STRING_BY_ORDER(test,d,json_object,3);
    }
  return 1;
}

// create a json_object direclty from struct test_1
struct json_object * json_c_test_1_to_json_auto(  struct test_1* test)
{
  struct json_parser_ctx * ctx = calloc(1,sizeof(struct json_parser_ctx));

  char * wb = {"test_1abcdtest_2"};
  char * buffer;
  
  // allocate  100 words, 1024 characters
  alparser_init(&ctx->alparser,100,1024);
  buffer=ctx->alparser.word_buffer.buf;
  memcpy(buffer,wb,32);
    
  // 1. allocate json_object
  struct json_object * growable = aljson_new_growable(ctx,'{');
  // 2. add members
  struct alhash_datablock char_buffer;

  // todo should convert an int to json int char representation
  char_buffer.data.ptr=buffer;
  char_buffer.length=6;
    
  struct json_object * object = aljson_new_json_string(ctx->tokenizer, '0', &char_buffer);

  char_buffer.data.ptr=buffer+6;
  char_buffer.length=1;
  // should create json pair with name of field ...
  struct json_object * key = aljson_new_json_string(ctx->tokenizer, '"', &char_buffer);
  struct json_object * pair = aljson_new_pair_key(ctx, pair);
  pair->pair.value=object;
  aljson_add_to_growable(ctx,&growable->growable,pair);
  // 3. concretize ( struct can't grow or be edited anymore ).
  return aljson_concrete(ctx, growable);

}

int json_c_test_2_from_json_auto( struct test_2* test, struct json_object * json_object)
{
  if AL_JSON_IS_DICT(json_object)
    {
      AL_GET_JSON_INT_WITH_NAME(test,a,json_object);
      AL_GET_JSON_STRUCT( test_1, test,c,json_object,1,WITH_NAME);
      AL_GET_JSON_STRUCT_POINTER( test_1, test,e,json_object,2,WITH_NAME);
    }
  else if AL_JSON_IS_LIST(json_object)
    {
      AL_GET_JSON_INT_BY_ORDER(test,a,json_object,0);
      AL_GET_JSON_STRUCT( test_1, test,c,json_object,1,BY_ORDER);
      AL_GET_JSON_STRUCT_POINTER( test_1, test,e,json_object,2,BY_ORDER);
    }
  return 1;
}


int main(int argc, char ** argv)
{

  todo("parse input stream and run test_1 parsing of a given json test");
  todo("then code C struct parser ... ");
  printf("NOT YET implemented");

  // stupid test : do we survive to NULL entries ?
  json_c_test_2_from_json_auto( NULL, NULL);
  return 0;
}
